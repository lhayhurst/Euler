#include <UnitTest++.h>
#include <TestReporterStdout.h>
#include <vector>
#include <iostream>
#include <algorithm>
#include <functional>
#include <cstring>
#include <map>
#include <unordered_map>
using namespace std;

/* If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9.
   The sum of these multiples is 23.

   Find the sum of all the multiples of 3 or 5 below 1000.
*/
TEST(ProblemOne)
 {

    auto sum = 0;
    for( auto i = 0; i < 999; i++ ) {
        if ( i % 3 == 0 || i % 5 == 0 ) {
            sum += i;
        }
    }
    CHECK_EQUAL( 232169, sum );

  }

/*
Each new term in the Fibonacci sequence is generated by adding the previous two terms.
By starting with 1 and 2, the first 10 terms will be:

    1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million,
find the sum of the even-valued terms.
*/

void fibonacci( long int max, function<void(long int&)> action ) {
    long int f1 = 1;
    long int f2 = 2;
    while ( f2 <= max ) {
       action( f2 );
       int tmp = f2;
       f2 = f1 + tmp;
       f1 = tmp;
    }
}

TEST(ProblemTwo)
{
    long int sum = 0;

    auto accumulator = [&sum](long int elem) {
        if ( elem % 2 == 0) {
            sum += elem;
        }
    };
    fibonacci( 4000000, accumulator );
    CHECK_EQUAL( 4613732, sum );
    //std::cout << sum << std::endl;
}



vector<unsigned long> prime_factors( unsigned long N ) {
    unsigned long d = 2;
    vector<unsigned long> ret(0);
    while ( N > 1  ) {
        while ( N % d == 0 ) {
            ret.push_back( d );
            N /= d;
        }
        d++;
    }
    return ret;

}
/*
The prime factors of 13195 are 5, 7, 13 and 29.

What is the largest prime factor of the number 600851475143 ?
*/

TEST(ProblemThree)
{
    unsigned long N = 600851475143;
    vector<unsigned long> factors = prime_factors( N );
    sort( factors.begin(), factors.end() );
    CHECK_EQUAL( 6857, factors.back() );
}

/* A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit
   numbers is 9009 = 91 99.

   Find the largest palindrome made from the product of two 3-digit numbers.
*/

TEST(ProblemFour)
{
   unsigned int answer = 0;
   for ( unsigned int i = 999; i >= 100; i-- ) {
       for ( unsigned int j = 999; j >= 100; j-- ) {
           unsigned int num = i * j;
           unsigned int reversed = 0;
           unsigned int n = num;
           while ( n > 0 ) {
              unsigned int lastdigit = n % 10;
              reversed = reversed * 10 + lastdigit;
              n /= 10;
           }
           if ( num == reversed ) {
               if ( num > answer ) {
                   answer = num;
               }

           }
       }
   }
   CHECK_EQUAL( 906609, answer );

}

/* 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.

What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
*/

//this function canbe more modern c++-y - remove the for loop et least.
unsigned int factoral( int factor ) {
    unsigned int product = 1;
    for( int i = 2; i <= factor; i++ ) {
        product *= i;
    }
    return product;
}

TEST(ProblemFive)
{
   /* this solution makes use of the fact that the smallest evenly divisible dumber is the
      product of the greatest power of each prime factor in the range */
   //map<unsigned long> powers;
   unordered_map<unsigned long, unsigned long> factors;
   for( unsigned long i = 2; i <= 20; i++ ) {
       vector<unsigned long> fas = prime_factors( i );
       unordered_map<unsigned long, unsigned long> factors_of_i;
       for( auto it = fas.begin(); it != fas.end(); it++ ) {
           factors_of_i[ *it ]++;
       }
       /* the below code pretty prints the factors
       cout << i << ": ";
       for( auto kv: factors_of_i ) {
           cout << kv.first << "^" << kv.second << "\t";
       }
       cout << endl;
       */
       for( auto lkv: factors_of_i ) {
           auto gkv = factors[lkv.first];
           if ( lkv.second > gkv ) {
               factors[lkv.first] = lkv.second;
           }
       }
   }

   //and finally calculate the product
   unsigned long result = 1;
   for( auto kv: factors) {
       unsigned long product = pow( kv.first, kv.second );
       result *= product;
   }
   CHECK_EQUAL( 232792560, result );

}


int main( int argc, char** argv )
{
  if( argc > 1 )
  {
      //if first arg is "suite", we search for suite names instead of test names
    const bool bSuite = strcmp( "suite", argv[ 1 ] ) == 0;

      //walk list of all tests, add those with a name that
      //matches one of the arguments  to a new TestList
    const UnitTest::TestList& allTests( UnitTest::Test::GetTestList() );
    UnitTest::TestList selectedTests;
    UnitTest::Test* p = allTests.GetHead();

    while( p )
    {
      for( int i = 1 ; i < argc ; ++i )
        if( strcmp( bSuite ? p->m_details.suiteName
                           : p->m_details.testName, argv[ i ] ) == 0 )
          selectedTests.Add( p );
       UnitTest::Test* q = p;
       p = p->next;
       q->next = NULL;
    }

      //run selected test(s) only
    UnitTest::TestReporterStdout reporter;
    UnitTest::TestRunner runner( reporter );
    return runner.RunTestsIf( selectedTests, 0, UnitTest::True(), 0 );

  }
  else
  {
    return UnitTest::RunAllTests();
  }
}
